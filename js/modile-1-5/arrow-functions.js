//                  РЕПЕТА Модуль 4, занятие 7? СТРЕЛОЧНЫЕ ФУНКЦИИ
/*
Это более лаконичный синтаксис для записи функции. Обычная функция - это у нас функциональное выражение. 
// Т.е. у нас есть переменная и в нее записывается функция. Стрелка - это тоже всегда функциональное выражение. 
// Т.е. декларативное создание для стрелки невозможно.
// Плюс их удобнее использовать для супер-супер маленьких коллбек функций.


const add = function (a, b, c) {
    
    return a + b + c;
};
console.log(add(5, 10, 15));

// Стрелка. И в этом теле функции могут выполнняться такие же инструкции, как обычно, и конечно же return

const addArrow = (a, b, c) => {
    return a + b + c;
};
console.log(addArrow(5, 4, 9));

// Если параметр всего один, то скобки можно опустить
// Если параметров вообще нету, то обязательны пустые скобки

const addArrowMini = a => {
    return a;
};
console.log(addArrowMini(5));
*/


// Если в теле функции нужно выполнить несколько действий, например иф какой-то есть, потом ретёрн.Т.е. больше операций, чем просто ретёрн
// То это называется явный возврат.
// Explicit  - явный возврат, когда return объявлен,  emplicit - неявный возврат
// Но если же это только ретёрн, то можно сделать неявный возврат.
// Опустить тело функции, а то, что хотим вернуть из неё, поставить сразу после стрелки.
// Это может быть выражение сравнения, любые математические операции
/*
const addArrow1 = (a, b, c) => {
    return a + b + c;
};

const addArrow2 = (a, b, c) => a + b + c;
console.log(addArrow2(5, 4, 9));
*/

/*
Теперь, помните, что у каждой функции есть локальная переменная arguments, которая у нее просто есть. 
Локальная переменная arguments хранит псевдомассив всех полученных аргументов
А вот у стрелочной функции этой локальной переменной нет. А как же получить доступ ко всем аргуиментам?
Просто ...rest собрать все аргументы и все. Это не распыление, а сбор, когда вы берете  много аргументов и собираете его в самый обычный массив. Это уже не псевдомассив.


const addArrow3 = (...args) => {
    console.log(args);
    return args;
};
addArrow3(5, 4, 9, 10, 11);
*/


/*
Перепишем на стрелку 
Интерпретатор фигурную скобку после стрелки не понимает как литерал объекта, а воспринимает как начало тела функции.
() - это выражение какое-то. Оно вычисляется и его результат возвращается. 
Поэтому, чтобы из функции с неявным возвратом вернуть объект, нужгно поставить его в эти круглые скобки


const fnA = function () {
    return {
        a:5,
    };
};
console.log(fnA());


const arrowFnA = () => ({ arrowA: 5 });
console.log(arrowFnA());
*/


/*
Перепишем на стрелку функцию фильтрации


const filter = (array, test) => { 
    filteredArray = [];

    for (const el of array) {
        console.log(el);
        const passed = test(el);

        if (passed) {
            filteredArray.push(el); 
        }
    };

    return filteredArray;
};

const r1 = filter([1, 2, 3, 4, 5, 6, 7], value => value >= 3);
console.log(r1);

const r2 = filter([1, 2, 3, 4, 5, 6, 7, 8, 9], value => value <= 4);
console.log(r2);



const fruits = [
    { name: "apples", quantity: 200, isFresh: true },
    { name: "grapes", quantity: 150, isFresh: false },
    { name: "bananas", quantity: 100, isFresh: true }, 
];

const r3 = filter(fruits, fruit => fruit.quantity >= 120);
console.log(r3);
*/



/* 
У стрелочной функции нет своего this. Т.е. внутри стрелочной функии вот это вот значение контекста, 
т.е. значение ключевого слова this определяется не в момент ее вызова, как у нормальной функции, а в момент объявления.
Там, где ты ее объявил, такой внешний контекст она и запомнила навсегда.


const showThis = () => {
    console.log(this);
};
showThis(); // Всегда при вызове в глобальной области видимости значение this будет undtfined.
// Если объявлена не в модуле, то значение будет window


// Я делаю объект user
const user = { name: 'Mango' };

//И я ему на свойство записываю ссылку на функцию showThis. И потом эту функцию вызываю в контексте user
user.showContext = showThis;

// Но this до сих пор будет undtfined, т.к. оно записалось гдето раньше при объявлении функции
// Контекст стрелки определяетмся местом ее объявления. И в нашем случае это this было объявлено в глобальной области видимости,
// поэтому его значение навсегда записалось как undtfined 
user.showContext();
*/
/*
Т.е. еще раз - где объявил, такой внешний контекст она и взяла.
Т.е. ага внутри метода showName() объявил, метод ссылается на userExamples, 
значит и this моей стрелки будет ссылаться на userExamples, т.е. на контекст родительской функции


const userExamples = {
    fullName: 'Mango',
    showName() {
        console.log(this);
        console.log(this.fullName);

        // Теперь внутри этого метода я создаю обычную функцию
        const inner = function () {
            console.log('this внутри inner: ', this);
        };

        // И вот в момент вызова эта функция без какого-то контекста, без объекта вызывается, поэтому логично, что значение this будет undtfined
        inner();

        // А если сейчас поменять её на стрелку, то она начнет ссылаться на нашего userExamples, т.к. она объявлена внутри него
    },
};

userExamples.showName();
*/

                            // НИКОГДА не использовать стрелки как методы объекта.
                            
// Для объекта userExamples метод, т.е. функция showName() объявлена в глобальной области видимости,
// потому что сам объект в глобальной области видимости. И поэтому она навсегда запомнила this как undtfined
// Привязать контекст стрелки с помощью bind тоже невозможно.



                                // СТРЕЛКА-КОНСТРУКТОР
                            
// Также, стрелки не могут быть функциями конструкторов. Функция это объект, а у объектов есть 
// внутренних свойства - Call Construct. 
// Потому что у стрелки нет внутреннего свойства констракт.
// Поэтому она не может быть вызваана через new
/*
const User = function (name) {
    this.name = name;
};
console.log(new User('Mango'));


// Еще один пример , но со вложенными объектами

const objA = {
    x: 5,
    showX() {
        console.log(this.x);

        // А теперь буквально во время вызова этой функции создается еще один новый объект
        const objB = {
            y: 10,
            showThis() {
                console.log("this внутри showThis(): ", this);
            },
        };

        objB.showThis();
    },
};
objA.showX();

// А теперь если заменить на стрелку showThis(), то ее ершы будет ссылаться на внешний из объекта А, т.е. 
// из глобальной области видимости
*/