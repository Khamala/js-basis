
                            //  REDUCE Швейцарский нож для работы с коллекцией.
                            //  РЕПЕТА
/*
Поэлементно перебирает массив и возвращает что угодно. Заменяет все на свете.

Первым аргументом вы ставите функцию, которая будет вызываться для каждого элемента. В этой функции всегда есть как минимум 2 параметра: 
первое - это аккумулятор (acc)Б это как будто тотал при переборе через фор. И эта штука будет 
из предыдущего вызова функции передаваться в следующий. То, что на первой итерации отсюда вернется, 
пойдет на следующую итераци. в это параметр acc

Если не задали значение acc, то по умолчанию в него присвоится значение первого элемента коллекции.

Когда REDUCE пербрал до конца, то возвращается в итоге значение аккумулятора


const numbers = [5, 10, 15, 20, 25];

// Например, я могу посчитать общую сумму чисел в этом массиве

const total = numbers.reduce((acc, number) => acc + number, 0);
console.log(total);
*/

                    // ПРИМЕР из УРОКА - как из МАССИВа с помощью REDUCE вернуть ОБЪЕКТ
/*
const numbers = [5, 10, 15, 20, 25];

const total = numbers.reduce((acc, item, index) => {

    // И это означает буквально, я хочу, чтобы у тебя -акк, было свойство с ключем [`Ключ ${index}`],  
    // а сохрани в него значение item, т.е. значение элемента массива
    acc[`Ключ ${index}`] = item;  

    return acc; // И на каждой итерации нужно вернуть аккумулятор

}, {}); // Начальное значение акк это пустой объект

console.log(total);
*/






        // ЗАДАЧА 1. Мы подсчитывали общую сумму зарплат:
        // РЕПЕТА и такая же была на уроке
/*      
const salary = {
    mango: 100,
    poly: 50,
    ajax: 150,
};
// 1. Вытягиваем из объекта массив того, с чем нам надо чтото сделать.Т.е. массив значений зп. Массив чисел
// 2. И на нем вызываем редюс. Аккумулятор - будет пускай имя параметра total. 

const totalSalary = Object.values(salary).reduce(
    (total, value) => total + value,
    0,
);

console.log(totalSalary);
*/


        // ЗАДАЧА 2. Нам нужно насчитать общее количество часов, которые наиграли все игроки этого сервиса
        // РЕПЕТА и такая же была на уроке
/*
const players = [
    {id: 'player-1', name: 'Mango', timePlaued: 310, points: 54, online: false},
    {id: 'player-2', name: 'Poly', timePlaued: 470, points: 92, online: true},
    {id: 'player-3', name: 'Kiwi', timePlaued: 230, points: 48, online: true},
    {id: 'player-4', name: 'Ajax', timePlaued: 150, points: 71, online: false},
    {id: 'player-5', name: 'Chelsy', timePlaued: 80, points: 48, online: true},
];

const totalTimePlaued = players.reduce((totalTime, player) => 
    totalTime + player.timePlaued,
    0,
);
    
console.log(totalTimePlaued);
    
// Обычно если обращение только к одному свойству, то чаще деструктуризацию не ставят.
// А если к 2м и больше, то ставят.

const totalTimePlaued1 = players.reduce((totalTime, { timePlaued }) => 
    totalTime + timePlaued,
    0,
);
    
console.log(totalTimePlaued1);
*/



                    // ЗАДАЧА 3. Посчитаем корзину товаров
                    // РЕПЕТА и такая же была на уроке
/*
const cart = [
    { label: 'Apples', price: 100, quantity: 2 },
    { label: 'Bananas', price: 120, quantity: 3 },
    { label: 'Lemons', price: 70, quantity: 4 },
];

const totalAmount = cart.reduce((total, { price, quantity }) =>
    total + price * quantity,
    0,
);
console.log(totalAmount);


// ЗАДАЧА 4. Собираем все теги из твитов. 
// Получается, что нужно сохздать массив всех тегов. В редусе начальное значение акк это будет пустой массив

const tweets = [
    { id: '000', likes: 5, tags: ['js', 'nodejs'] },
    { id: '001', likes: 2, tags: ['html', 'css'] },
    { id: '002', likes: 17, tags: ['html', 'js', 'nodejs'] },
    { id: '003', likes: 8, tags: ['css', 'react'] },
    { id: '004', likes: 0, tags: ['js', 'nodejs', 'react'] }, 
];

// Здесть на каждой итерации мы в аккумулятор, т.е. в новый массив, сначала распыляем теги из массива тегов, а потом пушим их
// Но при таком коде будет ругаться линтер, т.к.наш код стал мутабельным.
// Он берет параметр в функцию и меняет его.А мы стремимся не менять максимально исходное

const allTags = tweets.reduce((acc, {tags}) => { 
    acc.push(...tags);
    return acc;
}, []);

console.log(allTags);

// Правильнее будет на каждой итерации создать сначала новый массив, а потом распылить туда старое

// Теперь он не меняет старое, а ты на каждой итерации создает новый массив и ты туда сначала распыляешь старый аккумулятор,
// а потом добавляешь теги с текущей итерации

const allTags1 = tweets.reduce((acc, { tags }) => { 
    return [...acc, ...tags]
}, []);
console.log(allTags1);

// И теперь можно убрать явный возврат

const allTags2 = tweets.reduce((acc, { tags }) => [...acc, ...tags], []);
console.log(allTags2);


// А теперь часто бывает нужно создать ОБЪЕКТ СТАТИСТИКИ, чтобы посмотреть, сколько каких тегов поставили люди.
// хочу вернуть такой теперь объект, где имя ключа - это имя тега, а значение ключа - это количество, сколько раз он встречается в массиве

// Я могу пройтись по этому новому массиву редьюсом
// Имя ключа леджит в переменной teg. И логика такая: если свойство с именем ключа  = teg есть на объекте, то увеличить ему значение на +1
// А как проверить, есть ли такое св-во на объекте?


const tegsStats = allTags.reduce((acc, teg) => {

    // если это св-во есть, то оно приведется к тру. А если нет, то вернет undefined, который приводится к фоллс и код не выполнится в ифе
    if (acc[teg]) {
        acc[teg] += 1;

      return acc;  
    };
 
    acc[teg] = 1;

    return acc;
}
, {});

console.log(tegsStats);

// Но за такой код линтеры будут сильно кричать, потому что вы по ссылке меняете чтото (значение св-ва) в объекте. Это мутабельный код
// Что значит - НЕМУТАБЕЛЬНО ? Значит, на каждой итерации нужно создат новый объект:


const tegsStats1 = allTags.reduce((acc, teg) => {
    if (acc[teg]) {
        // acc[teg] += 1;

        return {
            // Если свойство уже есть, то мы хотим создать новый объект, распылить туда старый аакумулятор, а потом
            ...acc,

            // А потом записать значение для этого свойства + 1. Т.е. текущее свойство тега увеличиваем на 1
            [teg]: acc[teg] + 1,
      };  
    };
 
    // А если этого свойства нету, то мы опять же создаем новый объект и в него тоже распыляем старый акк
    // и потом добавляем свойство с текущей итерации
    // [teg]:   это свойство со значением, которое лежит в переменной [teg]
    
    //acc[teg] = 1;

    return {
        ...acc,
        [teg]: 1,
    };
}
, {});

console.log(tegsStats1);


// И теперь можно переписать на тернарный оператор, но не объекты по тернарнику записывать, а тернарник поставить для записи в свойство объекта

const tegsStats2 = allTags.reduce((acc, teg) => {
    // Мы сразу будем возвращать объект, в котором будем записывать или менять значение свойства с помощью тернарного оператора
    
    return {
        ...acc,
        [teg]: acc[teg]
            ? acc[teg] + 1
            : 1,
    }
}
, {});

console.log(tegsStats2);

// Ну и если убрать явный возврат

const tegsStats3 = allTags.reduce(
    (acc, teg) => ({
        ...acc,
        [teg]: acc[teg] ? acc[teg] + 1 : 1,
        }),
    {},
);
console.log(tegsStats2);



*/
