                    //   РЕПЕТА Модуль 3, занятие 6 ОБЪЕКТЫ.
                    
/*
                    // РАСПЫЛЕНИЕ.  SPRED.   МАССИВЫ.
// Есть массив, надо получить все его аргументы. Это означает, возьми сделай новый массив, в который 
// распыли из массива внутри. Т.е. распаковывает массив в отдельные независимые значения.
// Синтаксис у SPRED и REST похожий ... , но в зависимости от того, где вы его поставите.
// Если REST идет всегда в самом конце, то распыление SPRED можно поставить в любом месте.
// Операция SPRED не деструктивная, она ничего не делает с массивом, который распыляет.
// Это буквально, возьми элементы этой коллекции и поставь в другую коллекцию.

const numbers = [...[1, 2, 3], 4, 5];
console.log(numbers);
*/
 
/*
                    // РАСПЫЛЕНИЕ.  SPRED.  ньюансы ОБЪЕКТОВ.
// Разница в том, что в массиве может быть сколько угодно одинаковых элементов, 
// а в объекте 2х одинаковых свойств быть не может. Сваой   ство в объекте - уникальное.
// Аналогично массивам, при деструктуризации объекта передается ссылка на оригинальный массив, 
// а не делается копия.

// !!! Можно также распылить и строку, потому что на самом деле распыляются ИТЕРИРУЕМЫЕ объекты

const obj1 = { a: 1, b: 5 };
const obj2 = { x: 1, };
const obj3 = { a: 4, b: 9 };

const newObj = {
    name: 'Я объект',
    ...obj1,
    ...obj2,
    ...obj3,
};

 console.log(newObj);
*/


/*
Юзер зашел на сайт. 
И там есть тема по умолчанию какая-то, показывать нотификации, допустим, по умолчанию, хайд сайд бар, допустим, по умолчанию стоит фоллс.
Т.е. ты зарегистрировался и там уже стоят настройки по умолчанию.
Это объект настроек, который применяется в интерфейсе. А юзер зашелл в свои настройки и решил поменять их. 
Эти изменения не хранятся в базе данных, это у юзера прями на компе, в браузере хранится. 
И ты зашел и сделал себе объект на то, что уже ты хочешь


const defaultSettings = {
    theme: 'light',
    showNotification: true,
    hideSidebar: false,
};

const userSettings = {
    // Нотификации ты захотел выключить. Клацнул чек-бокс 
    showNotification: false,
    // И хочешь чтобы сайдбар появился
    hideSidebar: true,
};

// Получается, нужно взять дефолтные настройки и слить с твоими, чтобы получить финальные настройки
// Сначала распыляются дефолтные настройки, а поверх них распыляются те, что ты выбрал
// Это никакое не наследование, а просто на базе 2х ты делаешь третий, с заменой.

const finalSettings = {
    ...defaultSettings,
    ...userSettings,
};
*/





                        //  ДЕСТРУКТУРИЗАЦИЯ ОБЪЕКТОВ.    
        
// Позволяет уквально распаковывать объекты и массивы. Большинство нащших данных - это будут объекты. 
// И в коде, когда вы хотите обраттиться к свойствам этих объектов, в коде будет это не красиво всен выгдлядеть.

// Деструктуризация нужна, чтобы в локальные переменные вытянуть их значения, 
// чтобы было удобно работать с ними в коде
// Оно идет и ищет в объекте свойство с таким именем, как указано в скобках, и записывает его в переменную
/*       
const playlist = {
    name: 'Мой плейлист',
    rating: 5,
    tracks: ['track-1', 'track-2', 'track-3', 'track-4'],
    trackCount: 4,
};

const { rating, tracks } = playlist;

console.log(tracks);

// Если в деструктуризацию добавить свойство, которого нету, но оно вам для чего-то нужно,
// то можно его добавить и присвоить ему значение по умолчанию, т.е. дефолтное.
// Т.е. это не добавит новое свойство на объект, а просто в эту локальную переменную запишет значениею

const { name, author = 'fhgh' } = playlist;

console.log(author);


// Если на объекте свойство с одним имененем, а я хочу,чтобы моя переменная по-другому называлась, то
// можно это сделать таким синтаксисом :
// Буквально ты говорищь, положи в локальную переменную numberOfTrecks значение
// вот этого свойства trackCount с объекта playlist
// Т.е. это так возможно ПЕРЕНАЗВАТЬ переменную, в которую ты деструктуризируешь какое-то свойство.
// Ну и если нужно в эту переменную задать дефолтное значение, то так:

const { trackCount: numberOfTrecks = 0 } = playlist;
*/

                        // ГЛУБОКАЯ ДЕСТРУКТУРИЗАЦИЯ ОБЪЕКТОВ
// Это была простая деструктуризация, т.к. в объекте были свойства только первого уровня.
// Синтаксис глубокой деструктуризации:

// !!! ЗАПОМНИТЬ, НИКОГДА не деструктуризировать объекты, на которых есть функции
/*
const profile = {
    nameProf: 'Jacques Gluke',
    tag: 'jgluke',
    location1: 'Jamaica',
    avatar: 'http...png',
    stats: {
        followers: 5236,
        views: 4125,
        likes: 1236,
    },
};

const { nameProf, tag,
    stats: {
        followers,
        views,
        likes,
    }} = profile;
*/

                        // ДЕСТРУКТУРИЗАЦИЯ МАССИВОВ
/*                      
// В отличие от объектов массивы деструктуризируются с индексацией. Т.е. в каком порядке 
// объявили переменные. В первую переменную запишется значение элемента массива с индексом [0], 
// во вторую переменную элемент с индексом[1]  и т.д.
// А если нужно один элемент пропустить, например, записать в переменные первый элемент и третий, 
// то просто ставить запятую, как будто пропуск свойства.

const rgb = [255, 100, 80];

const [red, , blue] = rgb;

*/


 
                       // ПРАКТИЧЕСКИЙ юзкейс
/*
//Например, есть рейтинг авторов и нам нужно найти автора с самым большим рейтингом.

const authors = {
    kiwi: 4,
    poly: 7,
    ajax: 9,
    mango: 6,
};

    // Взяли массив из значений свойств объекта, распылили его в отдельные аргументы и 
    // применили к ним маз-макс. При таком способе есть только значения, нет самого автора, т.е.свойства
const ratings = Object.values(authors);
console.log(Math.max(...ratings));

    // а чтобы вывести вместе с именем автора

const keys = Object.keys(authors);

for ( const key of keys) { 
    console.log(key);
    console.log(authors[key]);
};

// ИЛИ - есть метод entries
// Он возвращает массив массивов. Массив, где нулевым элементом стоит ключ, а первым элементом - значение этого ключа
 
const entries = Object.entries(authors);
console.log(entries);

for (const entrie of entries) {
    const name = entrie[0];
    const rating = entrie[1];
    console.log(name, rating);
}
// Или можем деструктуризировать массив entrie
for (const entrie of entries) {
    const [name, rating] = entrie;
    console.log(name, rating);
}
// Но еще можно эту деструктуризацию сразу положить в переменную
for (const [name, rating] of entries) {
    console.log(name, rating);
}





                            // ОПЕРАЦИЯ REST

// Иногда в локальные переменные нужно вытащить только отдельные свойства, а не все.
// А все остальные свойства собрать в какой-то другой объект, чтобы использовать где-то дальше

const profile = {
    nameProf: 'Jacques Gluke',
    tag: 'jgluke',
    location1: 'Jamaica',
    avatar: 'http...png',
    stats: {
        followers: 5236,
        views: 4125,
        likes: 1236,
    },
};

const { nameProf, tag, location1, ...restProps } = profile;

// В переменную restProps соберется все, что мы не деструктуризировали явно
console.log(nameProf, tag, location1);
console.log(restProps);





            // ПАТТЕРН - ОБЪЕКТ НАСТРОЕК

// Если нужно, чтобы функция принимала разное количество аргументов

const fn = function (params) {
// И теперь мы хотим деструктуризировать этот объекткоторый передан в парамс
    
    const { name, age, isOnline, friends, hobbies, games } = params;

};

fn({
    name: 'Mango',
    age: 10,
    isOnline: true,
    friends: 5,
    hobbies: [],
    games: {},
});

*/

/* 
ПРИМЕР ДЕСТРУКТУРИЗАЦИИ МАССИВА ОБЪЕКТОВ С ОДИНАКОВЫМИ КЛЮЧАМИ


const array = [{ a: 1 }, { a: 1 }, { a: 1 }];

function foo(paramArray) {
  
  const [obj1, obj2, obj3] = paramArray;

  //const { a } = obj1;
  //const { a } = obj2;
  //const { a } = obj3;

 console.log(obj1, obj2, obj3);
 
};

foo(array);
*/