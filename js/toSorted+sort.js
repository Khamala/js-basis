
                                // МЕТОД toSorted
                                // Урок 10
/*
- ВОЗВРАЩАЕТ новый массив
- По умолчанию сортирует ПО ВОЗРАСТАНИЮ
- В отличие от sort он НЕ ДЕСТРУКТИВНЫЙ

// СОРТИРОВКА ЧИСЕЛ происходит так, что он сначала приведет все числа к строкам
// и потом сравнит их по unicode. Т.е. сравнение будет поэлементно.
// Чтобы решить эту проблему, нужно в метод callback

const numbers = [5, 4, 1, 9, 10, 7, 44, 25, 18];
const sorted = numbers.toSorted();
const sorted1 = numbers.toSorted((a, b) => a - b); // ДЛЯ сортировки ПО ВОЗРАСТАНИЮ
const sorted2 = numbers.toSorted((a, b) => b - a);// ДЛЯ сортировки ПО УБЫВАНИЮ

console.log(sorted); 
console.log(sorted1); 
console.log(sorted2); 
*/

/*
// СОРТИКОВКА СТРОК происходит также по unicode, где а маленькое больше, чем А большое.
// чтобы решить эту проблему, нужно передать в метод callback

const letters = ['d', 'D', 'a', 'A'];

const sorted = letters.toSorted((a, b) => a.localeCompare(b));   // ПРЯМО по алфавиту
const sortedInvers = letters.toSorted((a, b) => b.localeCompare(a));// ОБРАТНЫЙ ПОРЯДОК алфавиту
*/



















// РЕПЕТА.
/*
МЕТОД  sort. 

Вообще, есть разные интересные алгоритмы сортировки, но это немного не про это. 
Этот метод сортирует поэлементно, он относительно медленный. Но для повседневных фронтендских задач его достаточно. 
Поэлементная сортировка
ИЗМЕНЯЕТ ОРИГИНАЛЬНЫЙ МАССИВ. Поэтому, перед применением sort мы захотим сделать копию.


// По умолчанию - сортирует по возрастанию НО
// Если не передан никакой колбек для сортировки, то просто по возрастанию, но перед этим приводит элемент к строке и сортирует по юникоду

const numbers = [5, 9, 2, 7, 3, 1, 10];
numbers.sort();
console.log(numbers);

// Но если нам надо вдргут наоборот от большего к меньшему, то надо уже передавать compareFunktion - функцию сравнения (коллбек)
// На массиве намберс я могу вызвать метод сорт и передать в него функцию
// Она получает текущий элемент и следующий
// Если функция возвращает меньше нуля, то сорт поставит curEl перед nextEl. Т.к. это значит, что текущий элемент меньше следующего
// Если функция возвращает больше нуля, то сорт поставит curEl после nextEl. Т.к. это значит, что текущий элемент больше следующего

numbers.sort((curEl, nextEl) => { 
    return curEl - nextEl;
});

console.log(numbers);


// Минус этого метода в том, что количество элементов прямо пропорционально времени его работы.
//А все потому, что он перебирвает поэлементно

// Вы помните, что мы не хотим изменять оригинальный массив, поэтому необхордимо СДЕЛАТЬ КОПИЮ
// Для этого у вас есть или слайс или спред

const copy = [...numbers];   // Все, теперь это копия

const sortedNumbers = [...numbers].sort()

console.log(sortedNumbers);


СОРТИРОВКУ БУКВ НЕ ДОСЛУШАЛА
*/
