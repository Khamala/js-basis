                // РЕПЕТА Модуль 3, затятие 5 ОБЪЕКТЫ-1

                // ОБРАЩЕНИЕ К СВОЙСТВУ ОБЪЕКТА
/*               
                // 1. Синтаксис через точку:

const playlist = {
    name: 'Мой плейлист',
    rating: 5,
    tracks: ['track-1', 'track-2', 'track-3', 'track-4'],
    trackCount: 4,
};

console.log(playlist.name);
console.log(playlist.tracks);
*/

/*
                // 2. Синтаксис через квадратные скобки.

// Мы так записываем, что имя ключа без кавычек, но КЛЮЧ СВОЙСТВА ВСЕГДА СТРОКА!!!

// Если имя ключа хранится в переменной.
// И нужно получить значение свойства объекта, ключ которого хранится в переменной.

const propertyName = 'tracks'; 
console.log(playlist[propertyName]);

// Также можно обратиться по имени ключа через синтаксис квадратных скобок:

console.log(playlist['tracks']);
*/

/*
                // 3. КОРОТКАЯ ЗАПИСЬ СВОЙСТВ
                
// Создание объекта с динамическими ключами. У тега input есть 2 атрибута - name и value. 
// И вот ситуация - я отправил форму, какие - то 2 переменные, т.к.в коде у меня не бывает значения из ниоткуда. 
// Я всегда приходится значение из этого input, его имени и его значения, сохранить в какую - то переменную.

const userName = 'Mango';
const email = 'mango@gmail.com';

const signUpData = {
    // userName: userName,
    // email: email,

    userName,
    email,
};

console.log(signUpData);

// Т.е. да, нам надо будет что-то забирать из формы и создавать объект такого формата. Где userName: userName, первое это просто как строка имя ключа, 
// а второе это имя переменной и вместо нее подставится значение. Т.о. имя переменной и имя ключа совпадают.
*/

/*
                // 4. ВЫЧИСЛЯЕМЫЕ СВОЙСТВА

// Есть тег input и у него есть атрибут value. И у себя в коде мы будем вытаскивать
// имя этого input и значение этого input. 
// И теперь мне нужно составить объект такого формата, что имя ключа - то, что лежит в переменной inputName, 
// а значение свойства это то, что лежит в переменной 
// Интерпретатор вычисляет ключ из какой-то переменной inputValue
// <input name = 'color', value = 'tomato'>

const inputName = 'color';
const inputValue = 'tomato';

const colorPickerData = {
    [inputName]: inputValue,
};

console.log(colorPickerData);
*/


/*
                // 5. МЕТОДЫ ОБЪЕКТА

// Метод объекта - это самая обычная функция, но которая работает со свойствами какого-то одного объекта. 
// Т.е. методы объекта используются для того, чтобы работать со свойствами.
// Если у моей сущности есть характеристики, как у массива есть элементы, то как мне их изменить?
// У массива для этого есть всякие методы пуши, сплайсы, слайсы и т.д.

                // this
// В методах объекта НИКОГДА НЕ используется имя самого объекта!
// Внутри каждой функции есть this - это КОНТЕКСТ ВЫЗОВА ФУНКЦИИ. Это буквально ссылка на тот объект, 
// который эту функцию вызвал. this есть только у функции



const playlist = {
    name: 'Мой плейлист',
    rating: 5,
    tracks: ['track-1', 'track-2', 'track-3', 'track-4'],
    // Это называется вычисляемые свойства. Т.е. ДИНАМИЧЕСКОЕ ЗНАЧЕНИЕ
    // Т.е.я могу на базе одного свойства, которое у меня есть, получить другое значение
    // trackCount: 4,

    getName() {
        console.log(playlist.name);
    },

    // Метод для изменения имени объекта.
    changeName(newName) {
        this.name = newName;
            return this.name;
    },

    // Метод - Добавить трек
    addTrack(newTrack) {
        this.tracks.push(newTrack);
    // У меня есть на объекте СТАТИЧЕСКОЕ СВОЙСТВО trackCount.
    // И оно пока что не обновляется, когда я изменяю количество треков. НО ТАК ДЕЛАТЬ ПЛОХО. 
    // Количество треков в плейлисте не нужно хранить на самом плейлисте, потому что у нас 
    // всегда есть количество треков как длинна массива.
    // Также и с корзиной товаров- нет смысла ее общую сумму хранить
    
    // this.trackCount = this.tracks.length;
        return this.tracks;
    },

    getTrackCount() {
        return this.tracks.length;
    },

    // Метод - Обновить рейтинг
    updateRating(newRating) {
        this.rating = newRating;
        return this.rating;
    },
};
playlist.getName();
playlist.changeName('My playlist');
playlist.addTrack('new track');
playlist.updateRating(7);

console.log(playlist.getTrackCount());
*/


/*
                // 6. ПЕРЕБОР ОБЪЕКТА

// Метод for...in перебирает не только собственные свойства объекта, но и унаследованные. 
// Также for in не используется для перебора массивов. МОЖНО, но НЕ НУЖНО.

// Помните, есть конструкторы Number, Boolean, Array - из которых вот эти базовые типы и получаются
// Есть родительский конструктор Object со специальными методами: Object.keys, Object.values

 
const feedback = {
    good: 5,
    neutral: 10,
    bad: 3,
};
    // Я буквально говорю - получи массив ключей из объекта feedback и уже после этого, 
    // я получнный массив перебираю через обычный for of

const keys = Object.keys(feedback);
let totalFeedback = 0;

for (const key of keys) {
    // key это переменная, в которую на каждой итерации записывается имя ключа, 
    // а синтаксис квадратных скобок позволяет получить значение этого ключа
    totalFeedback += feedback[key];
}

console.log(totalFeedback);
*/

/*
// Объекты бывают просто как хранилища, в них нет методов. Этот наш объект просто хранит данные

// Если нам не нужно сами получить ключи, а только взять значения ключей и все, то  Object.values
// Object.keys ВОЗВРАЩАЕТ МАССИВ КЛЮЧЕЙ
// Object.values ВОЗВРАЩАЕТ МАССИВ ЗНАЧЕНИЙ

const values = Object.values(feedback);

console.log(values);

for (const value of values) {
    totalFeedback += value;
};

console.log('totalFeedback: ', totalFeedback);
*/







