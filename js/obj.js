                // РЕПЕТА Модуль 3, затятие 5 ОБЪЕКТЫ-1

                // ОБРАЩЕНИЕ К СВОЙСТВУ ОБЪЕКТА
/*               
                // 1. Синтаксис через точку:

const playlist = {
    name: 'Мой плейлист',
    rating: 5,
    tracks: ['track-1', 'track-2', 'track-3', 'track-4'],
    trackCount: 4,
};

console.log(playlist.name);
console.log(playlist.tracks);
*/

/*
                // 2. Синтаксис через квадратные скобки.

// Мы так записываем, что имя ключа без кавычек, но КЛЮЧ СВОЙСТВА ВСЕГДА СТРОКА!!!

// Если имя ключа хранится в переменной.
// И нужно получить значение свойства объекта, ключ которого хранится в переменной.

const propertyName = 'tracks'; 
console.log(playlist[propertyName]);

// Также можно обратиться по имени ключа через синтаксис квадратных скобок:

console.log(playlist['tracks']);
*/

/*
                // 3. КОРОТКАЯ ЗАПИСЬ СВОЙСТВ
                
// Создание объекта с динамическими ключами. У тега input есть 2 атрибута - name и value. 
// И вот ситуация - я отправил форму, какие - то 2 переменные, т.к.в коде у меня не бывает значения из ниоткуда. 
// Я всегда приходится значение из этого input, его имени и его значения, сохранить в какую - то переменную.

const userName = 'Mango';
const email = 'mango@gmail.com';

const signUpData = {
    // userName: userName,
    // email: email,

    userName,
    email,
};

console.log(signUpData);

// Т.е. да, нам надо будет что-то забирать из формы и создавать объект такого формата. Где userName: userName, первое это просто как строка имя ключа, 
// а второе это имя переменной и вместо нее подставится значение. Т.о. имя переменной и имя ключа совпадают.
*/

/*
                // 4. ВЫЧИСЛЯЕМЫЕ СВОЙСТВА

// Есть тег input и у него есть атрибут value. И у себя в коде мы будем вытаскивать
// имя этого input и значение этого input. 
// И теперь мне нужно составить объект такого формата, что имя ключа - то, что лежит в переменной inputName, 
// а значение свойства это то, что лежит в переменной 
// Интерпретатор вычисляет ключ из какой-то переменной inputValue
// <input name = 'color', value = 'tomato'>

const inputName = 'color';
const inputValue = 'tomato';

const colorPickerData = {
    [inputName]: inputValue,
};

console.log(colorPickerData);
*/


/*
                // 5. МЕТОДЫ ОБЪЕКТА

// Метод объекта - это самая обычная функция, но которая работает со свойствами какого-то одного объекта. 
// Т.е. методы объекта используются для того, чтобы работать со свойствами.
// Если у моей сущности есть характеристики, как у массива есть элементы, то как мне их изменить?
// У массива для этого есть всякие методы пуши, сплайсы, слайсы и т.д.

                // this
// В методах объекта НИКОГДА НЕ используется имя самого объекта!
// Внутри каждой функции есть this - это КОНТЕКСТ ВЫЗОВА ФУНКЦИИ. Это буквально ссылка на тот объект, 
// который эту функцию вызвал. this есть только у функции


*/
const playlist = {
    name: 'Мой плейлист',
    rating: 5,
    tracks: ['track-1', 'track-2', 'track-3', 'track-4'],
    trackCount: 4,

    getName() {
        console.log(playlist.name);
    },

    // Метод для изменения имени объекта.
    changeName(newName) {
        this.name = newName;
            return this.name;
    },

    // Метод - Добавить трек
    addTrack(newTrack) {
        this.tracks.push(newTrack);
    // У меня есть на объекте СТАТИЧЕСКОЕ СВОЙСТВО trackCount.
    // И оно пока что не обновляется, когда я изменяю количество треков. НО ТАК ДЕЛАТЬ ПЛОХО. 
    // Количество треков в плейлисте не нужно хранить на самом плейлисте, потому что у нас 
    // всегда есть количество треков как длинна массивов.
    

        this.trackCount = this.tracks.length;
        return this.tracks;
    },

    // Метод - Обновить рейтинг
    updateRating(newRating) {
        this.rating = newRating;
        return this.rating;
    },
};

playlist.getName();
playlist.changeName('My playlist');
playlist.addTrack('new track');
playlist.updateRating(7);

console.log(playlist);











/*

*/